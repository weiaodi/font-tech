要理解**修改现有属性时隐藏类不会变化**，需要从 **隐藏类的设计目标** 和 **属性修改的底层逻辑** 两方面拆解：

### 一、隐藏类的核心职责：记录“属性布局”，而非“属性值”

隐藏类（Hidden Class）的核心是 **描述对象的“结构”**，而非“值”。它关注的是：

- 属性的**名称**（`name`、`age` 等）
- 属性的**内存偏移量**（属性在对象内存中的位置）
- 属性的**类型信息**（如 `name` 是字符串，`age` 是数字）

但**属性的具体值**（如 `age: null` 或 `age: 30`）并不存储在隐藏类中，而是直接存在对象的内存空间里。

### 二、“修改属性值”的底层流程

当你执行 `user.age = 30` 时，实际发生的是：

1. 引擎通过隐藏类找到 `age` 属性的**内存偏移量**（比如偏移量是 `1`）。
2. 直接在对象的内存空间中，将该偏移量位置的值从 `null` 改为 `30`。

这个过程中，**对象的“结构”（属性名称、偏移量、类型）没有变化**，因此隐藏类不需要更新。

### 三、对比“动态添加属性”：结构真的变了

如果是动态添加新属性（如 `user.gender = 'male'`），情况完全不同：

1. 原隐藏类只记录了 `name` 和 `age` 的布局。
2. 添加 `gender` 时，对象的“结构”发生了本质变化（新增了属性名称、偏移量）。
3. 引擎必须**创建新的隐藏类**，记录新的属性布局。

### 四、隐藏类不变的本质：“结构稳定”是优化的基础

V8 等引擎的优化逻辑依赖一个前提：**如果对象的结构（属性布局）稳定，那么访问属性的方式可以被缓存**（内联缓存）。

修改属性值时：

- 结构（隐藏类）不变 → 缓存的偏移量、类型信息仍然有效 → 访问速度快。

动态增删属性时：

- 结构（隐藏类）变化 → 缓存失效 → 引擎需要重新计算偏移量、重建缓存 → 性能下降。

### 五、极端情况：类型变化会触发隐藏类变更吗？

如果修改属性值时**类型发生巨变**（如 `age` 从 `number` 变成 `object`），会不会触发隐藏类变更？  
答案是：**可能会，但场景非常有限**。

现代引擎（如 V8）会做“类型灵活处理”：

- 若属性值类型在小范围内变化（如 `number` 和 `null`，`null` 本质被视为特殊的 `object`），隐藏类可能不变。
- 若类型完全突变（如 `age` 从 `number` 变成函数），引擎可能会调整隐藏类的类型信息，但这对普通业务代码影响极小（因为很少这么改）。

### 总结：修改值 ≠ 改结构

修改现有属性的值时，**对象的“结构”（属性名称、偏移量、类型）并未改变**，因此隐藏类不需要更新。

而动态增删属性会改变结构，必须创建新的隐藏类——这就是两者性能差异的核心原因。

理解这一点后，就能明白“预定义属性、避免动态增删”的优化价值：**让对象结构稳定，最大化利用隐藏类和内联缓存**。
