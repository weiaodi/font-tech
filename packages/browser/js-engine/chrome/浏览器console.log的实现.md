要理解 `console.log` 打印对象时的“快照”与“实时值”差异，需要结合 **JavaScript 对象的存储方式** 和 **浏览器控制台的工作机制** 来分析。下面分步骤拆解：

### **一、JavaScript 对象的存储本质：引用类型**

在 JavaScript 中，对象（包括数组、函数等）是 **引用类型**，其存储特点是：

- 变量（如 `a`）在栈内存中存储的是 **指向堆内存的地址**（类似“指针”）。
- 实际的属性和值（如 `a.b.c`）存储在 **堆内存** 中。

例如：

```javascript
const a = { b: { c: 1 } };
// 栈中：a → 堆地址（假设为 0x123）
// 堆中（0x123）：{ b: 堆地址（0x456） }
// 堆中（0x456）：{ c: 1 }
```

当执行 `a.b.c = 2` 时，本质是 **修改堆内存中 `c` 的值**（堆地址不变，仅值更新）：

```javascript
a.b.c = 2;
// 堆中（0x456）的 c 从 1 变为 2（地址仍为 0x456）
```

### **二、console.log 对对象的“快照”与“实时读取”**

当用 `console.log` 打印对象时，浏览器控制台的行为分两种情况：

#### 1. **未展开对象时：显示“快照”**

- 当你执行 `console.log(a)` 时，浏览器会 **立即记录对象的引用地址**，并显示一个“快照”（即打印瞬间对象的属性结构）。
- 这个快照仅记录属性的“存在性”和“基础值类型”（如字符串、数字），但 **不会深拷贝整个对象**。
- 例如：
  ```javascript
  const a = { b: { c: 1 } };
  console.log(a); // 打印时快照显示 { b: { c: 1 } }
  a.b.c = 2; // 后续修改堆中值
  ```
  此时控制台未展开的对象会显示 `{ b: { c: 1 } }`（快照）。

#### 2. **展开对象时：实时读取堆内存**

- 当你点击展开对象时，浏览器会 **重新通过引用地址去堆内存中读取最新值**，而不是使用之前的快照。
- 因此，上面的例子中，展开后会看到 `{ b: { c: 2 } }`（实时值）。

#### 为什么会这样？

- 浏览器这样设计是为了 **节省性能**：如果每次打印对象都深拷贝一份完整数据，对于复杂对象（如大数组、嵌套对象）会消耗大量内存和时间。
- 而“快照+实时读取”的方式，既保证了打印的轻量化，又能让开发者看到对象的最新状态。

### **三、特殊情况：值类型与引用类型的区别**

如果打印的是 **值类型**（如数字、字符串、布尔值），则不会有这种“差异”，因为值类型直接存储在栈中，`console.log` 会立即记录其值，后续修改不会影响已打印的结果：

```javascript
let x = 1;
console.log(x); // 打印 1（值类型快照，固定不变）
x = 2; // 后续修改不影响已打印结果
```

### **四、验证与示例**

通过一段代码可直观看到差异：

```javascript
const obj = { prop: '初始值' };
console.log('打印时的对象：', obj); // 未展开显示 { prop: '初始值' }
obj.prop = '修改后的值'; // 改变堆中值
// 此时展开控制台的对象，会显示 { prop: '修改后的值' }
```

控制台输出效果：

- 未展开：`打印时的对象：{ prop: '初始值' }`
- 展开后：`打印时的对象：{ prop: '修改后的值' }`

### **总结**

- **核心原因**：对象是引用类型，`console.log` 打印的是引用地址，未展开时显示快照（结构），展开时实时读取堆内存最新值。
- **开发中的注意点**：调试时若需固定打印某个时刻的对象状态，需手动深拷贝（如 `console.log(JSON.parse(JSON.stringify(obj)))`），避免被后续修改干扰。

这种机制是浏览器控制台的设计选择，理解它能帮助你更准确地通过 `console.log` 调试代码。

### **用实际操作理解“展开”**

打开浏览器（如 Chrome）的控制台（按 F12 或 Ctrl+Shift+I），运行这段代码：

```javascript
const obj = { prop: '初始值' };
console.log('打印时的对象：', obj); // 第1步：打印对象
obj.prop = '修改后的值'; // 第2步：修改属性
```

你会看到这样的输出：

1. **未展开时**：控制台显示 `打印时的对象：{ prop: '初始值' }`  
   这里的 `{ prop: '初始值' }` 是一个“缩略展示”，类似对象的“快照封面”。

2. **展开后**：点击对象左侧的小箭头（▶），会展开显示内部细节，此时会看到 `prop: "修改后的值"`  
   展开的过程，就是浏览器去内存中重新读取对象最新值的过程。

### **为什么会有这种差异？**

#### 1. **JavaScript 对象是“引用类型”**

- 对象 `obj` 在内存中分为两部分：
  - **栈内存**：存储对象的“引用地址”（类似一个指针，指向堆内存）。
  - **堆内存**：存储实际的属性和值（如 `{ prop: '初始值' }`）。
- 当你执行 `obj.prop = '修改后的值'` 时，修改的是**堆内存中**的实际值，而栈中的引用地址不变。

#### 2. **控制台的“延迟求值”机制**

- 当你用 `console.log` 打印对象时，浏览器并不会立即读取堆内存中的所有属性值并保存，而是**只记录对象的引用地址**，并显示一个“临时快照”（未展开时的样子）。
- 这个“临时快照”是**打印瞬间的属性状态**（比如 `初始值`），目的是为了节省性能（避免每次打印都拷贝整个对象）。
- 当你**手动展开对象**时，浏览器才会**通过引用地址去堆内存中读取最新的值**，所以会看到修改后的 `修改后的值`。

### **类比：像查看文件的快捷方式**

可以把 `obj` 比作电脑里的“快捷方式”（引用地址），指向硬盘里的实际文件（堆内存中的对象）：

- 你第一次看到快捷方式时，系统显示文件的“当前名称”（类似未展开的快照：`初始值`）。
- 之后你修改了文件的名称（类似 `obj.prop = '修改后的值'`）。
- 当你双击快捷方式打开文件时（类似展开对象），看到的是修改后的名称（`修改后的值`）。

### **总结**

- **“未展开”**：控制台显示的是打印瞬间的“快照封面”，基于当时的属性状态生成。
- **“展开”**：手动点击箭头查看内部属性时，控制台会实时去堆内存中读取对象的最新值。
- 核心原因：对象是引用类型，控制台为了性能采用“延迟求值”，只在展开时才读取最新数据。

这就是为什么修改对象后，展开控制台的对象能看到最新值，而未展开时显示的是旧值的原因。
