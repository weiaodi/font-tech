在 JavaScript 中，垃圾回收（GC）是自动内存管理的核心机制，其执行逻辑涉及复杂的算法和策略。以下从底层原理到具体实现进行详细解析：

### **一、核心算法与工作流程**

#### 1. **标记-清除（Mark-Sweep）**

这是最基础的 GC 算法，分为两个阶段：

1. **标记阶段**：

   - 从**根对象**（如全局变量、调用栈中的变量）出发，递归遍历所有可达对象，并标记它们为“活动”。
   - 不可达对象（如未被引用的局部变量）将不会被标记。

2. **清除阶段**：
   - 遍历整个堆内存，回收未被标记的对象所占用的空间。

```javascript
// 示例：变量作用域与可达性
function example() {
  const a = { value: 1 }; // a 可达
  const b = { value: 2 }; // b 可达

  // 函数执行结束后：
  // a 和 b 不再被引用，变为不可达 → 下次 GC 时被回收
}
```

#### 2. **标记-整理（Mark-Compact）**

为解决标记-清除算法导致的**内存碎片**问题，引入标记-整理：

1. **标记阶段**：同标记-清除。
2. **整理阶段**：
   - 将所有存活对象移动到内存的一端，形成连续的内存块。
   - 清理边界外的所有内存空间。

#### 3. **复制算法（Copying）**

将内存分为两个相等的区域：

1. **From 空间**：当前分配对象的区域。
2. **To 空间**：用于复制存活对象的区域。

**工作流程**：

- 新对象分配在 From 空间。
- GC 时，将存活对象复制到 To 空间，然后清空 From 空间。
- 交换 From 和 To 空间的角色。

**优势**：

- 避免内存碎片，分配速度快（只需移动指针）。
- **缺点**：内存利用率仅 50%。

### **二、V8 引擎的分代回收策略**

V8 将内存分为**新生代**（Young Generation）和**老生代**（Old Generation），采用不同的回收策略：

#### 1. **新生代内存**

- **特点**：存放短期对象（如函数局部变量），对象生命周期短。
- **回收算法**：Scavenge 算法（基于复制算法）。
- **空间划分**：
  - **From 空间**（又称 Eden 空间）：新对象分配在此。
  - **To 空间**（又称 Survivor 空间）：用于复制存活对象。

**回收流程**：

1. 当 From 空间满时，触发 GC。
2. 将存活对象复制到 To 空间。
3. 清空 From 空间，交换 From 和 To 空间的角色。
4. **对象晋升**：若对象经过多次 GC 仍存活，会被移至老生代。

#### 2. **老生代内存**

- **特点**：存放大对象或长期存活对象（如全局变量、闭包）。
- **回收算法**：标记-清除 + 标记-整理。

**回收流程**：

1. **增量标记**：将标记过程分成多个小步骤，穿插在其他代码执行中，减少 GC 暂停时间。
2. **并发清除/整理**：在主线程执行的同时，使用后台线程进行垃圾回收。

### **三、触发 GC 的具体条件**

#### 1. **内存阈值**

- **新生代**：当 Eden 空间满时触发 Scavenge 回收。
- **老生代**：当老生代内存达到预设阈值（如 2GB）时触发标记-清除。

#### 2. **周期性执行**

- 引擎定期执行 GC，即使内存未达到阈值，以防止碎片积累。

#### 3. **手动触发（仅 Node.js）**

```javascript
// 需要使用 --expose-gc 标志启动 Node.js
global.gc(); // 手动触发 GC
```

### **四、优化 GC 性能的关键技巧**

#### 1. **减少临时对象创建**

频繁创建短期对象会导致新生代 GC 频繁触发：

```javascript
// 低效：每次调用生成新对象
function calculate() {
  return { a: 1, b: 2 }; // 每次调用创建新对象
}

// 高效：复用对象
const result = { a: 0, b: 0 };
function calculate() {
  result.a = 1;
  result.b = 2;
  return result;
}
```

#### 2. **避免闭包导致的内存泄漏**

```javascript
// 错误：闭包持有对 largeArray 的永久引用
function createLeak() {
  const largeArray = new Array(1000000);
  return function () {
    return largeArray.length; // 闭包阻止 largeArray 被回收
  };
}

// 正确：在不需要时释放引用
function createComponent() {
  let data = new Array(1000000);

  const cleanUp = () => {
    data = null; // 手动释放引用
  };

  return {
    cleanUp,
  };
}
```

#### 3. **使用 WeakMap/WeakSet**

- 弱引用不会阻止对象被 GC：

```javascript
const weakMap = new WeakMap();
const obj = {};

weakMap.set(obj, 'data'); // obj 可被正常回收

// 当 obj 没有其他引用时，GC 会自动回收 obj 及其在 WeakMap 中的关联数据
```

### **五、GC 性能监控工具**

#### 1. **Chrome DevTools**

- **Memory 面板**：

  - 录制堆快照，分析对象保留路径（Retainers）。
  - 监控内存增长趋势，检测泄漏。

- **Performance 面板**：
  - 记录 GC 活动，测量 GC 耗时。
  - 分析 GC 频率与应用性能的关系。

#### 2. **Node.js 工具**

```javascript
// 监控内存使用
console.log(process.memoryUsage());
/* 输出示例：
{
  rss: 20746240,      // 驻留集大小（进程占用的总内存）
  heapTotal: 7333888,  // 堆内存总大小
  heapUsed: 4982352,   // 已使用的堆内存
  external: 8772       // C++ 对象占用的内存
}
*/
```
