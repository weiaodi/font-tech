Diff 算法是 React 和 Vue 等前端框架实现高效更新 DOM 的关键，通过比较新旧虚拟 DOM 树的差异，只更新需要改变的真实 DOM 部分，从而提升性能。不过，二者的 Diff 算法在实现细节和策略上存在一些区别，下面从多个方面进行详细分析。

### 核心算法复杂度

- **React**：React 采用了双指针遍历的方式进行 Diff 比较，其核心算法复杂度为 $O(n)$。这一复杂度是通过设定一些前提条件达成的，例如只对同层节点进行比较，若发现节点类型不同，就直接替换该节点及其子节点，而不会深入比较子节点。这种做法在一定程度上简化了算法逻辑，但在某些场景下可能会导致不必要的节点替换。
- **Vue**：Vue 2 的 Diff 算法复杂度同样为 $O(n)$，采用了双端比较的策略，通过比较新旧节点列表的首尾节点，尽可能复用已有的 DOM 节点，减少 DOM 操作。Vue 3 在此基础上进行了优化，采用了快速 Diff 算法，进一步提升了性能。

### 节点比较策略

- **React**：React 对比节点时，先比较节点的类型（如元素标签名、组件类型）。若类型不同，就直接替换整个节点及其子节点；若类型相同，则更新节点的属性和内容。对于列表节点，React 要求开发者为每个节点提供唯一的 `key` 属性，以便更准确地识别节点，提高 Diff 效率。若没有提供 `key`，React 会默认按顺序比较节点，这在节点插入、删除等操作时可能会导致效率低下。

```jsx
// React 列表渲染示例
const list = ['apple', 'banana', 'cherry'];
const listItems = list.map((item, index) => <li key={index}>{item}</li>);
```

- **Vue**：Vue 2 在比较节点时，同样先比较节点类型，若类型不同则替换节点。对于列表节点，Vue 也建议使用 `key` 来提高 Diff 效率，但 `key` 的使用方式相对灵活。Vue 2 采用双端比较算法，同时比较新旧节点列表的首尾节点，通过移动、插入和删除节点来更新 DOM。Vue 3 的快速 Diff 算法结合了最长递增子序列算法，能更高效地处理列表节点的移动和更新。

```vue
<!-- Vue 列表渲染示例 -->
<template>
  <ul>
    <li v-for="item in list" :key="item.id">{{ item.name }}</li>
  </ul>
</template>
```

### 动态节点标记

- **React**：React 没有专门的动态节点标记机制，每次更新时都会对整个虚拟 DOM 树进行遍历和比较。这种方式虽然简单直接，但在大型应用中可能会带来一定的性能开销。
- **Vue**：Vue 3 引入了动态节点标记机制，通过在编译阶段分析模板，标记出哪些节点是动态的（即会发生变化的节点）。在进行 Diff 比较时，只对这些动态节点进行比较和更新，从而减少不必要的比较操作，提高性能。

### 组件更新策略

- **React**：在 React 中，当组件的 `props` 或 `state` 发生变化时，默认会重新渲染整个组件及其子组件。虽然可以通过 `shouldComponentUpdate`（类组件）或 `React.memo`（函数组件）来控制组件是否需要重新渲染，但这需要开发者手动进行优化。
- **Vue**：Vue 的组件更新是基于响应式系统的，当组件的响应式数据发生变化时，Vue 会自动追踪哪些 DOM 节点依赖于这些数据，并只更新这些相关的节点。这种细粒度的更新策略使得 Vue 在更新组件时更加高效。

综上所述，React 和 Vue 的 Diff 算法都旨在提高 DOM 更新的效率，但在实现细节和策略上存在差异。React 的 Diff 算法相对简单直接，而 Vue 的 Diff 算法在不断优化，采用了更多的技巧和策略来提升性能。
