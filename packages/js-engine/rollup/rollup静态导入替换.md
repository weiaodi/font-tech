“静态导入替换”是 Rollup 实现高效打包的核心技术之一，它通过**编译时静态分析**替代**运行时动态解析**，从而消除模块解析开销。以下是具体原理和示例解析：

### **1. ES 模块的原生行为**

在浏览器或 Node.js 中，ES 模块的 `import` 语句是**静态声明**，需在**编译阶段**完成解析，但实际执行时仍需通过**模块加载器**动态获取模块内容。例如：

```javascript
// 模块 A
import { add } from './math.js'; // 静态声明，但运行时需加载 math.js
console.log(add(1, 2));
```

- **运行时开销**：引擎需解析 `./math.js` 的路径，加载文件，执行模块代码，最后获取 `add` 函数。

### **2. Rollup 的静态导入替换**

Rollup 在打包时会**提前解析所有依赖**，将 `import` 语句直接替换为目标模块的代码，避免运行时的动态解析过程。具体步骤如下：

#### **（1）编译时解析依赖**

Rollup 构建依赖图时，会递归解析每个模块的导入路径，找到对应的模块代码。例如：

```javascript
// math.js
export const add = (a, b) => a + b;

// main.js
import { add } from './math.js'; // Rollup 找到 math.js 并提取 add 函数
```

#### **（2）内联模块代码**

将目标模块的导出内容直接内联到当前模块中，移除 `import` 语句。打包后的代码如下：

```javascript
// 打包后（简化版）
const add = (a, b) => a + b; // 直接内联 add 函数，无需 import
console.log(add(1, 2));
```

#### **（3）优化引用关系**

对于复杂的模块结构（如多层嵌套导入），Rollup 会建立**直接引用关系**，避免层级查找：

```javascript
// utils.js
export const math = { add: (a, b) => a + b };

// main.js
import { math } from './utils.js';
console.log(math.add(1, 2));

// 打包后：直接引用 add 函数
const add = (a, b) => a + b;
console.log(add(1, 2)); // 跳过 math 对象层级，直接调用
```

### **3. 消除的运行时开销**

通过静态导入替换，Rollup 避免了以下运行时成本：

1. **模块路径解析**：无需处理 `./math.js` 等相对路径
2. **网络请求/文件读取**：浏览器环境中无需发起 HTTP 请求，Node.js 中无需读取文件系统
3. **模块执行顺序管理**：无需维护模块执行队列和作用域链
4. **动态作用域查询**：直接访问变量，无需通过模块对象（如 `module.exports`）查找

### **4. 与 Webpack 的对比**

Webpack 使用**模块化运行时（Module Runtime）**，通过 `__webpack_require__` 函数动态加载模块：

```javascript
// Webpack 打包后（简化版）
const math = __webpack_require__('./math.js'); // 运行时动态加载
console.log(math.add(1, 2));
```

- **开销来源**：每次调用 `__webpack_require__` 都需要执行路径解析、缓存查询、模块执行等步骤
- **Rollup 的优势**：完全静态化处理，运行时无额外函数调用

### **5. 适用场景与限制**

#### **（1）适用场景**

- **库（Library）打包**：追求极致性能和代码体积
- **无运行时环境**：如浏览器环境中的立即执行代码（IIFE）

#### **（2）限制**

- **动态导入不适用**：`import('./module.js')` 仍需保留运行时逻辑
- **CommonJS 模块**：需通过插件转换为 ES 模块才能优化
- **循环依赖**：可能导致替换逻辑复杂（Rollup 会自动处理大多数情况）

### **6. 原理总结**

| 阶段         | ES 原生行为              | Rollup 行为                 |
| ------------ | ------------------------ | --------------------------- |
| **编译时**   | 解析 `import` 语句       | 内联模块代码，移除 `import` |
| **运行时**   | 动态加载模块、解析作用域 | 直接执行内联代码，无开销    |
| **核心优化** | 运行时模块系统开销       | 编译时提前解决依赖关系      |

通过静态导入替换，Rollup 将模块解析的所有工作提前到**编译阶段**完成，使得打包后的代码在运行时更接近“原生代码”的执行效率，这也是其成为库打包首选工具的重要原因之一。
