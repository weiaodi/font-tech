pnpm 根据不同的场景和需求，会分别使用 **硬链接（Hard Link）** 和 **符号链接（Symbolic Link，软链接）**。以下是具体的使用时机和原理：

### 一、**硬链接的使用场景**

#### 1. **全局存储与项目依赖的文件共享**

- **场景**：当多个项目依赖同一个包的相同版本时，pnpm 通过硬链接避免重复存储文件内容。
- **原理**：
  - 首次安装包时（如 `lodash@4.17.21`），pnpm 将文件解压到 **全局存储目录**（如 `~/.pnpm-store`）。
  - 后续其他项目安装相同版本的包时，pnpm 不会复制文件，而是在项目的 `node_modules` 中创建硬链接指向全局存储中的文件。
- **示例**：

  ```
  # 全局存储目录
  ~/.pnpm-store/v3/files/
  └── lodash@4.17.21/
      ├── index.js
      └── package.json

  # 项目 A 的 node_modules
  project-a/node_modules/
  └── lodash/
      ├── index.js → 硬链接到 ~/.pnpm-store/.../lodash@4.17.21/index.js
      └── package.json → 硬链接到 ~/.pnpm-store/.../lodash@4.17.21/package.json
  ```

- **优势**：节省磁盘空间，提升安装速度。

#### 2. **同一项目内的重复依赖处理**

- **场景**：项目的直接依赖和嵌套依赖引用了同一包的相同版本。
- **原理**：
  - 例如，项目直接依赖 `react@17.0.2`，而 `react-router-dom` 也依赖 `react@17.0.2`。
  - pnpm 会将两个依赖的文件都通过硬链接指向全局存储中的同一物理文件。
- **优势**：确保依赖文件的一致性，避免版本冲突。

### 二、**符号链接的使用场景**

#### 1. **构建依赖树的层级结构**

- **场景**：创建项目 `node_modules` 中的目录结构，使依赖关系符合 `package.json` 的声明。
- **原理**：
  - **直接依赖**：项目根目录的 `node_modules` 中的包是符号链接，指向全局存储中的对应版本。
  - **嵌套依赖**：依赖内部的 `node_modules` 中的子依赖也是符号链接。
- **示例**：
  ```
  # 项目结构
  project/
  ├── package.json
  └── node_modules/
      ├── react@17.0.2/ → 符号链接到 ~/.pnpm-store/react@17.0.2
      │   ├── package.json
      │   └── node_modules/
      │       └── object-assign@4.1.1/ → 符号链接到 ~/.pnpm-store/object-assign@4.1.1
      └── react-router-dom@6.14.2/ → 符号链接到 ~/.pnpm-store/react-router-dom@6.14.2
  ```
- **优势**：
  - 严格遵循依赖声明，避免幽灵依赖。
  - 清晰反映依赖关系，便于调试。

#### 2. **处理工作空间（Workspaces）**

- **场景**：在 monorepo 项目中，子包之间的引用需要实时映射。
- **原理**：
  - 例如，项目有两个子包 `packages/core` 和 `packages/ui`，`ui` 依赖 `core`。
  - pnpm 会在 `ui/node_modules/@scope/core` 中创建符号链接，指向 `packages/core` 的源码目录。
- **优势**：开发时无需频繁发布包，修改源码即时生效。

### 三、**对比总结**

| **场景**                   | **硬链接**                | **符号链接**                |
| -------------------------- | ------------------------- | --------------------------- |
| 全局存储与项目间的文件共享 | ✅ 必须使用硬链接         | ❌ 符号链接无法共享文件内容 |
| 构建依赖树的目录结构       | ❌ 硬链接无法创建目录层级 | ✅ 符号链接可指向任意目录   |
| 处理 monorepo 工作空间     | ❌ 源码需要实时映射       | ✅ 符号链接指向源码目录     |
| 避免重复存储相同版本的包   | ✅ 硬链接指向同一物理文件 | ❌ 符号链接仍需复制文件内容 |

### 四、**技术细节补充**

1. **硬链接的限制**：

   - 只能指向文件，不能指向目录。
   - 只能在同一文件系统内创建（如不能跨磁盘分区）。

2. **符号链接的特性**：

   - 可以指向文件或目录，甚至可以指向不存在的路径。
   - 跨平台支持需要注意：
     - Windows 需要管理员权限或启用开发者模式才能创建符号链接。
     - pnpm 会自动处理这些差异，但极端情况下可能需要调整系统配置。

3. **验证方法**：
   - 在 Linux/macOS 上，使用 `ls -l` 查看文件权限，硬链接显示相同的inode号，符号链接显示 `->` 指向的路径。
   - 在 Windows 上，符号链接会显示为 `<SYMLINK>` 或 `<SYMLINKD>`（目录）。

### 五、**常见问题解答**

1. **为什么不全部用硬链接？**  
   硬链接只能指向文件，无法构建目录层级结构。依赖树需要通过符号链接创建嵌套的 `node_modules` 目录。

2. **符号链接会影响性能吗？**  
   符号链接的解析开销极小，几乎可以忽略不计。相比传统npm/yarn的扁平化结构，pnpm的符号链接反而能提升模块查找速度。

3. **硬链接共享文件会导致版本冲突吗？**  
   不会。pnpm 的全局存储会为不同版本的包创建独立目录（如 `lodash@4.17.21` 和 `lodash@4.17.22`），每个版本的文件通过硬链接隔离。

### 六、**总结**

- **硬链接** 用于解决 **文件内容的重复存储** 问题，确保同一版本的包只存储一次。
- **符号链接** 用于构建 **依赖树的逻辑结构**，确保依赖关系严格遵循 `package.json` 的声明。

两者结合，使pnpm在 **磁盘空间利用**、**安装速度** 和 **依赖管理严格性** 上全面超越传统包管理器。
